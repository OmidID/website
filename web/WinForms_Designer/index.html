<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <!--[if lt IE 9]>
    <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->
</head>
<body>
<h2 id="installation">Installation</h2>
<h3 id="mono">Mono</h3>
<p><code>git clone </code><a href="https://github.com/mono/mwf-designer.git"><code>https://github.com/mono/mwf-designer.git</code></a><br /><code>make; make run</code></p>
<p>The WinForms Designer <strong>requires</strong> <del><a href="Compiling_Mono#http://localhost:4000/Building_Mono_from_the_Subversion_Repository" title="wikilink"> Mono SVN Head</a>.</del> Mono 2.0 or newer.</p>
<p>However if you do indeed run it on <a href="Compiling_Mono#http://localhost:4000/Building_Mono_from_the_Subversion_Repository" title="wikilink"> Mono SVN Head</a> you could benefit from any bugfixes and improvements added since the last official release, because 99% of the actual code is part of the class libraries.</p>
<h3 id="visual-studio">Visual Studio</h3>
<p>If you want to use, run, contribute or debug the code with Visual Studio, Microsoft.NET and Windows - no problem. Just follow these 3 easy steps:</p>
<p><code>git clone </code><a href="https://github.com/mono/mwf-designer.git"><code>https://github.com/mono/mwf-designer.git</code></a></p>
<ol>
<li>Install Python - <a href="http://python.org/download/">http://python.org/download/</a></li>
<li>Run &quot;Prepare Visual Studio Build.bat&quot;</li>
<li>Open mwf-designer.sln with Visual Studio and you are done!</li>
</ol>
<p>What is happening automatically behind the scenes is the generation of a Mono.Design assembly - a subset of Mono's System.Design. The designer is then compiled with this assembly referenced.</p>
<p>The python script will:</p>
<ul>
<li>Download a subset of Mono System.Design assembly's source code from SVN</li>
<li>Apply a set of patches to make it run against Microsoft .NET</li>
<li>Change namespaces to &quot;Mono.Design&quot;.</li>
</ul>
<h3 id="mono-with-mono.design">Mono with Mono.Design</h3>
<p><code>git clone </code><a href="https://github.com/mono/mwf-designer.git"><code>https://github.com/mono/mwf-designer.git</code></a><br /><code>make mono-design &amp;&amp; make run</code></p>
<p>What is happening automatically behind the scenes is the generation of a Mono.Design assembly - a subset of Mono's System.Design. The designer is then compiled with this assembly referenced.</p>
<p>The python script will:</p>
<ul>
<li>Download a subset of Mono System.Design assembly's source code from SVN</li>
<li>Apply a set of patches to make it run against Microsoft .NET</li>
<li>Change namespaces to &quot;Mono.Design&quot;.</li>
</ul>
<h2 id="status">Status</h2>
<p>Unfortunately the designer is not ready yet for proper use. More information below.</p>
<p>99% of the functionality of the windows forms designer is in the System.Design assembly where the .NET 2.0 Design-Time Framework is and on where most of the development takes place.</p>
<p>The main stumble point is the lack of true Control transparency (WS_EX_TRANSPARENT), which is not yet supported by the MWF X11 backend, but is required for a proper Drag and Drop and other interaction (snap lines, etc) on the design service. There is WinForms bug in our bug tracker for this problem - <a href="http://bugzilla.novell.com/show_bug.cgi?id=323819">http://bugzilla.novell.com/show_bug.cgi?id=323819</a>.</p>
<p>Currently the designer can:</p>
<ul>
<li>Load C# Windows Forms form generated by Visual Studio/MS.NET</li>
<li>Add simple controls, such as buttons and panels from the toolbox and modify their properties.</li>
<li>Move and resize those controls.</li>
<li>Undo/Redo/Cut/Copy/Paste those controls.</li>
<li>Persist the form modifications back to source code compatible with Visual Studio/MS.NET.</li>
</ul>
<h2 id="bugs-patches-questions">Bugs, Patches, Questions</h2>
<p><em>Bugs</em> can be filed on the Mono bug tracker and should be assigned to me (Ivan N. Zlatev) - contact AT i-nz.net.. For more information on how to file bugs take a look at the <a href="http://localhost:4000/Bugs" title="wikilink">Bugs</a> wiki page.</p>
<p><em>Patches</em> can be send to the mono-devel-list or mono-winforms-list <a href="http://localhost:4000/Mailing Lists" title="wikilink">Mailing Lists</a>. That's also the place to ask questions. Please follow the <a href="http://localhost:4000/Coding_Guidelines" title="wikilink"> Mono Code Style Guidelines</a>.</p>
<h2 id="screenshots">Screenshots</h2>
<p><img src="http://localhost:4000/files/mwf-designer.png" title="fig:http://localhost:4000/files/mwf-designer.png" alt="http://localhost:4000/files/mwf-designer.png" /> <img src="http://localhost:4000/files/mwf-designer-win32.png" title="fig:http://localhost:4000/files/mwf-designer-win32.png" alt="http://localhost:4000/files/mwf-designer-win32.png" /></p>
<h2 id="todos">TODOs</h2>
<p>The best way to find out something you want to work on is to play with the designer and see what doesn't work or you don't like. Below are some related important tasks I have sorted in groups in semi-chronological order.</p>
<p>For background information on how the designer works check <a href="#.NET_Design-http://localhost:4000/Time_Framework" title="wikilink">#.NET_Design-Time_Framework</a></p>
<h3 id="task-packs">Task Packs</h3>
<p><del>''' New, Close '''</del></p>
<ul>
<li><del>Implement New -&gt;*</del></li>
<li><del>Implement Close Document</del></li>
<li><del>Doesn't support multi-component selection, because it only handles the ISelectionService.PrimarySelection and not the GetSelectedComponents.</del></li>
</ul>
<p><strike> <strong>Error Reporting</strong></p>
<ul>
<li><em>Designer</em>
<ul>
<li>Implement an IUIService. An easy to access place in the frontend where errors/warning will be shown, but also debug and trace information from the Design-Time code in debug mode.</li>
</ul></li>
<li><em>Serialization</em>
<ul>
<li>Make use of the IUIService.</li>
<li>Uncomment the try-catches in DesignerSerializationManager.</li>
<li>Refactor current CWLs in the serializers to something actually useful to print more detailed information on the currently (de)serialized expression.</li>
<li>May be create some sort of a TraceContext?</strike></li>
</ul></li>
</ul>
<p><strike>''' Undo/Redo (Cut, Copy, Paste) '''</p>
<ul>
<li><em>Serialization</em>
<ul>
<li>Implement: UndoEngine, ComponentSerializationService, CodeDomComponentSerializationService, CodeDomDesignerLoader.IDesignerSerializationService</li>
</ul></li>
<li><em>Surface</em>
<ul>
<li>Implement MenuCommandService : IMenuCommandService</li>
<li>MenuCommand - update to 2.0 and review current code.</li>
<li>Transactions must be created for:
<ul>
<li>creating components</li>
<li>destroying components</li>
<li>moving controls</strike></li>
</ul></li>
</ul></li>
</ul>
<p>''' Quick Fixes Fun Pack '''</p>
<ul>
<li><em>Serializers</em>
<ul>
<li><del>ControlCodeDomSerializer - Resume/SuspendLayout.</del></li>
<li>ContainerCodeDomSerializer - to serialize the container for the components and its disposing.</li>
</ul></li>
<li><del><em>MWF Designers</em></del>
<ul>
<li><del>DocumentDesigner has &quot;is Form&quot; code (sets TopLevel to false) which should go in a FormDocumentDesigner.</del></li>
</ul></li>
<li><em>Surface</em>
<ul>
<li>IDesignerHost.Activate is invoked after the root component is added to the host. This is just my guess. It has to be further investigated when, where and by what should that be invoked.</li>
<li>DesignerHost.Deactivated is never fired.</li>
<li>Currently there is a fallback DesignerHost.CreateDesigner because many designers are missing.</li>
</ul></li>
<li><em>Designers</em>
<ul>
<li>Check ControlDesigner.OnContextMenu and related.</li>
</ul></li>
</ul>
<p>''' Resources (De)Serialization '''</p>
<p>Everything that has Localizable (true) attribute gets serialized to a resource.</p>
<p>VS.Net creates a global Properties.resx for the project, where it stores the resources and also Properties.Designer.cs, where it generates properties with the name of the resource. On this basis it just serializes property references when it comes to resource serialization. Properties.* probably get's compiled and loaded from a temporary assembly before the deserialization process is invoked.</p>
<p><strike><em>' PropertyGrid</em>'</p>
<ul>
<li>Current designer's custom PropertyGrid.cs code is ugly and needs a clean rewrite.</li>
<li><em>Events Editing (MWF)</em>
<ul>
<li>Implement EventsTab.</li>
<li>Add EventsTab support in the PropertyGrid control.</strike></li>
</ul></li>
</ul>
<p>''' New selection/DnD/resize service '''</p>
<ul>
<li>Implement the System.Windows.Forms.Design.Behavior namespace (BehaviorService, etc) to replace the current IUISelectionService.</li>
<li>Requires true Control transparency (WS_EX_TRANSPARENT), which is not yet supported by the MWF X11 backend. MWF bug - <a href="http://bugzilla.novell.com/show_bug.cgi?id=323819">http://bugzilla.novell.com/show_bug.cgi?id=323819</a> .</li>
</ul>
<p>''' ComponentTray '''</p>
<ul>
<li>Depends on the Behavior-based selection service.</li>
</ul>
<p>''' Menu editing '''</p>
<ul>
<li><em>Designer</em>
<ul>
<li>Implement IMenuEditorService.</li>
</ul></li>
<li><em>MWF Designers</em>
<ul>
<li>Menu has a designer in a Visual Studio assembly (Microsoft.VisualStudio.Windows.Forms.MenuDesigner) - fix that.</li>
</ul></li>
</ul>
<p>''' DesignerActions '''</p>
<ul>
<li>Surface
<ul>
<li>Implement DesignerActionService, DesignerActionUIService, DesignerAction* and DesignerActionUI*</li>
</ul></li>
</ul>
<p>''' Extender Providers '''</p>
<ul>
<li><em>Surface</em>
<ul>
<li>Review ExtenderService : IExtenderProviderService, IExtenderListServiceIExtenderService implementation.</li>
</ul></li>
<li><em>Serializers</em>
<ul>
<li>Support for (De)Serialization of &quot;provided&quot; properties.</li>
</ul></li>
</ul>
<p>''' AmbientValueAttribute - <a href="http://msdn2.microsoft.com/en-us/library/system.componentmodel.ambientvalueattribute.aspx">http://msdn2.microsoft.com/en-us/library/system.componentmodel.ambientvalueattribute.aspx</a> '''</p>
<ul>
<li><em>Serializers</em>
<ul>
<li>Just add a handling of AmbientValueAttribute in PropertyCodeDomSerializer.ShouldSerialize(...)</li>
</ul></li>
</ul>
<p>''' ISupportInitialize and ctor (IContainer container) '''</p>
<ul>
<li><em>Serializers and Surface</em>
<ul>
<li>ISupportInitialize - <a href="http://msdn2.microsoft.com/en-us/library/system.componentmodel.isupportinitialize.aspx">http://msdn2.microsoft.com/en-us/library/system.componentmodel.isupportinitialize.aspx</a></li>
<li>Detection and handling of a constructor to accept the IContainer as a parameter: ctor (IContainer container) - <a href="http://books.google.com/books?id=CpgQthE6v_0C&amp;pg=PA246&amp;lpg=PA246&amp;ots=VFVg1OvrMv&amp;sig=LjPu15hzKWFFIJnIjBOqM8z-ts0#PPA248,M1">http://books.google.com/books?id=CpgQthE6v_0C&amp;pg=PA246&amp;lpg=PA246&amp;ots=VFVg1OvrMv&amp;sig=LjPu15hzKWFFIJnIjBOqM8z-ts0#PPA248,M1</a></li>
</ul></li>
</ul>
<p>''' Visual Inheritance '''</p>
<ul>
<li>InheritanceService, InheritanceAttribute, &quot;Modifier&quot; Design-Time property. How is the Modifier property persisted for the project?</li>
</ul>
<h3 id="support-classes">Support Classes</h3>
<h4 id="serializers">Serializers</h4>
<ul>
<li><strike> ControlCodeDomSerializer</li>
<li>ControlCollectionCodeDomSerializer </strike></li>
<li>DataGridViewRowCollectionCodeDomSerializer</li>
<li>ImageListCodeDomSerializer</li>
<li>TableLayoutControlCollectionCodeDomSerializer</li>
<li>TableLayoutPanelCodeDomSerializer</li>
<li>ToolStripCodeDomSerializer</li>
<li>ToolStripMenuItemCodeDomSerializer</li>
</ul>
<h4 id="designers">Designers</h4>
<ul>
<li>AxHostDesigner</li>
<li>BindingNavigatorDesigner</li>
<li>BindingSourceDesigner</li>
<li>ButtonBaseDesigner</li>
<li>ComboBoxDesigner</li>
<li>DataGridDesigner</li>
<li>DataGridViewColumnDesigner</li>
<li>DataGridViewComboBoxColumnDesigner</li>
<li>DataGridViewDesigner</li>
<li>DateTimePickerDesigner</li>
<li>FlowLayoutPanelDesigner</li>
<li>FolderBrowserDialogDesigner</li>
<li>GroupBoxDesigner</li>
<li>ImageListDesigner</li>
<li>LabelDesigner</li>
<li>ListBoxDesigner</li>
<li>ListViewDesigner</li>
<li>MaskedTextBoxDesigner</li>
<li>MonthCalendarDesigner</li>
<li>NotifyIconDesigner</li>
<li>OpenFileDialogDesigner</li>
<li><del>PanelDesigner</del></li>
<li>PictureBoxDesigner</li>
<li>PrintDialogDesigner</li>
<li>PropertyGridDesigner</li>
<li>RadioButtonDesigner</li>
<li>SaveFileDialogDesigner</li>
<li>ScrollableControlDesigner</li>
<li>SplitContainerDesigner</li>
<li>SplitterDesigner</li>
<li>SplitterPanelDesigner</li>
<li>StatusBarDesigner</li>
<li>TabControlDesigner</li>
<li>TableLayoutPanelDesigner</li>
<li>TabPageDesigner</li>
<li>TextBoxBaseDesigner</li>
<li>TextBoxDesigner</li>
<li>ToolBarButtonDesigner</li>
<li>ToolBarDesigner</li>
<li>ToolStripContainerDesigner</li>
<li>ToolStripContentPanelDesigner</li>
<li>ToolStripDesigner</li>
<li>ToolStripDropDownDesigner</li>
<li>ToolStripItemDesigner</li>
<li>ToolStripMenuItemDesigner</li>
<li>ToolStripPanelDesigner</li>
<li>TrackBarDesigner</li>
<li>TreeViewDesigner</li>
<li>UpDownBaseDesigner</li>
<li>WebBrowserBaseDesigner</li>
</ul>
<h4 id="propertygrid-editors">PropertyGrid Editors</h4>
<ul>
<li>System.Windows.Forms.Design.BorderSidesEditor</li>
<li>Windows.Forms.Design.HelpNamespaceEditor</li>
<li>Windows.Forms.Design.ImageCollectionEditor</li>
<li>Windows.Forms.Design.ImageIndexEditor</li>
<li>Windows.Forms.Design.LinkAreaEditor</li>
<li>Windows.Forms.Design.ListViewSubItemCollectionEditor</li>
<li>Windows.Forms.Design.MaskedTextBoxTextEditor</li>
<li>Windows.Forms.Design.MaskPropertyEditor</li>
<li>Windows.Forms.Design.SelectedPathEditor</li>
<li>Windows.Forms.Design.ShortcutKeysEditor</li>
<li>Windows.Forms.Design.StyleCollectionEditor</li>
<li>Windows.Forms.Design.ToolStripCollectionEditor</li>
<li>Windows.Forms.Design.ToolStripImageIndexEditor</li>
<li>Windows.Forms.Design.TreeNodeCollectionEditor</li>
<li>Windows.Forms.Design.DataGridColumnCollectionEditor</li>
<li>Windows.Forms.Design.DataGridColumnStyleFormatEditor</li>
<li>Windows.Forms.Design.DataGridColumnStyleMappingNameEditor</li>
<li>Windows.Forms.Design.DataGridTableStyleMappingNameEditor</li>
<li>Windows.Forms.Design.DataGridViewCellStyleEditor</li>
<li>Windows.Forms.Design.DataGridViewColumnCollectionEditor</li>
<li>Windows.Forms.Design.DataGridViewColumnDataPropertyNameEditor</li>
<li>Windows.Forms.Design.DataGridViewComponentEditor</li>
<li><del>System.ComponentModel.Design.MultilineStringEditor</del> - stubbed</li>
<li><del>Windows.Forms.Design.DataMemberFieldEditor</del> - stubbed</li>
<li><del>Windows.Forms.Design.DataMemberListEditor</del> - stubbed</li>
<li><del>Windows.Forms.Design.FormatStringEditor</del> - stubbed</li>
<li><del>Windows.Forms.Design.ListControlStringCollectionEditor</del></li>
<li><del>Windows.Forms.Design.StringArrayEditor</del></li>
<li><del>Windows.Forms.Design.StringCollectionEditor</del></li>
<li><del>Windows.Forms.Design.TabPageCollectionEditor</del></li>
</ul>
<h4 id="menu-commands">Menu Commands</h4>
<p>All of the commands below are added by DocumentDesigner.Initialize(...). This was found by the means of the following SpyMenuCommandService added to a DesignerSurface on MSNET.</p>
<div class="csharp">
<pre><code>&lt;code&gt;
public class SpyMenuCommandService : MenuCommandService
{
    public SpyMenuCommandService (IServiceProvider provider) : base (provider)
    {
    }
    
    public override void AddCommand (MenuCommand command)
    {
        Console.WriteLine (&quot;[Command:] &quot; + command.ToString () + Environment.NewLine);
        Console.WriteLine (&quot;=== Stack Trace ===&quot; + Environment.NewLine);
        Console.WriteLine (Environment.StackTrace);
        Console.WriteLine (&quot;===================&quot; + Environment.NewLine);
        base.AddCommand (command);
    }
}
&lt;/code&gt;</code></pre>
</div>
<ul>
<li><strong>StandardCommands</strong>
<ul>
<li>AlignBottom</li>
<li>AlignHorizontalCenters</li>
<li>AlignLeft</li>
<li>AlignRight</li>
<li>AlignToGrid</li>
<li>AlignTop</li>
<li>AlignVerticalCenters</li>
<li>BringToFront</li>
<li>CenterHorizontally</li>
<li>CenterVertically</li>
<li><strike>Copy</li>
<li>Cut</li>
<li>Delete</strike></li>
<li>HorizSpaceConcatenate</li>
<li>HorizSpaceDecrease</li>
<li>HorizSpaceIncrease</li>
<li>HorizSpaceMakeEqual</li>
<li>Paste</li>
<li>SelectAll</li>
<li>SendToBack</li>
<li>SizeToControl</li>
<li>SizeToControlHeight</li>
<li>SizeToControlWidth</li>
<li>SizeToGrid</li>
<li>SnapToGrid</li>
<li>TabOrder</li>
<li>VertSpaceConcatenate</li>
<li>VertSpaceDecrease</li>
<li>VertSpaceIncrease</li>
<li>VertSpaceMakeEqual</li>
<li>ShowGrid</li>
<li>LockControls</li>
</ul></li>
</ul>
<ul>
<li><strong>MenuCommands</strong>
<ul>
<li>KeyDefaultAction</li>
<li>KeySelectNext</li>
<li>KeySelectPrevious</li>
<li>KeyMoveLeft</li>
<li>KeySizeWidthDecrease</li>
<li>KeyMoveRight</li>
<li>KeySizeWidthIncrease</li>
<li>KeyMoveUp</li>
<li>KeySizeHeightIncrease</li>
<li>KeyMoveDown</li>
<li>KeySizeHeightDecrease</li>
<li>KeyCancel</li>
<li>KeyNudgeLeft</li>
<li>KeyNudgeDown</li>
<li>KeyNudgeRight</li>
<li>KeyNudgeUp</li>
<li>KeyNudgeHeightIncrease</li>
<li>KeyNudgeHeightDecrease</li>
<li>KeyNudgeWidthDecrease</li>
<li>KeyNudgeWidthIncrease</li>
<li>DesignerProperties</li>
<li>KeyReverseCancel</li>
</ul></li>
</ul>
<h2 id="known-limitations">Known Limitations</h2>
<p>Not supported currently are, as follows.</p>
<h3 id="design-surface">Design Surface</h3>
<ul>
<li>DesignerOptions, WindowsFormsDesignerOptionService</li>
<li>Extender Providers - <a href="http://msdn2.microsoft.com/en-us/library/ms171835.aspx">http://msdn2.microsoft.com/en-us/library/ms171835.aspx</a></li>
<li>LicenseContext</li>
</ul>
<h3 id="codedom-deserialization">CodeDom (De)Serialization</h3>
<ul>
<li>No creation expression is serialized for nested components by the ComponentCodeDomSerializer. I can't think of a use case where this would be required.</li>
<li>InheritanceService, InheritanceAttribute - what are those for?</li>
</ul>
<h2 id="net-design-time-framework">.NET Design-Time Framework</h2>
<p>The .NET Design-Time framework has a highly abstracted, extensible and complex service-oriented architecture which provides loose coupling between components, containers, services and the designer tool.</p>
<p>In the .NET Design-Time architecture components associate their Design-Time functionality independent of the design tool. A list of Design-Time services is provided, which communicate with the components, designers and between each other. The design surface is composed by those services, the designers and the components. The designer tool hosts the design surface and makes use of the available services as well as adds additional such.</p>
<p>The architecture makes use of attributes with metadata to describe behaviour for components and their members. Dynamic addition, removal and modification of the metadata of the components is possible.</p>
<figure>
<img src="http://localhost:4000/files/dt_1.png" title="Illustration 1: .NET Design-Time Framework Architecture Overview" alt="Illustration 1: .NET Design-Time Framework Architecture Overview" /><figcaption><em>Illustration 1: .NET Design-Time Framework Architecture Overview</em></figcaption>
</figure>
<h3 id="loose-coupling-concepts">Loose Coupling Concepts</h3>
<p>Loose coupling is a key concept which formed the design of the Design-Time framework due to the extensibility and modularity it provides.</p>
<h4 id="components-containers-sites">Components, Containers, Sites</h4>
<p>At the core of the Design-Time framework is an interface called <em>IComponent</em>. Anything that implements this interface is called a component. Components have three important characteristics:</p>
<ol>
<li>They can be owned by/hosted in a container.</li>
<li>They can request services from the Site.</li>
<li>They can have a name assigned.</li>
</ol>
<p>The first characteristic essentially allows the lifetime of the component to be controlled by the container. The second characteristic gives the component access to functionality provided by other parts of the framework and the designer tool. The third characteristics allows the container to assign unique identifier to each component. Components are design-time aware through their Site.</p>
<p><img src="http://localhost:4000/files/dt_2.png" title="fig:Illustration 2: Component, Site, Container Relation" alt="Illustration 2: Component, Site, Container Relation" />This is a fundamental concept as it provides full abstraction of visual and non visual components. Also the component can be a Windows Forms or an ASP.NET control and as long as it implements ''IComponent ''that will not be of significance to the design-time framework.</p>
<figure>
<img src="http://localhost:4000/files/dt_3.png" title="Illustration 3: Component, Site, Container Class Diagram" alt="Illustration 3: Component, Site, Container Class Diagram" /><figcaption><em>Illustration 3: Component, Site, Container Class Diagram</em></figcaption>
</figure>
<h4 id="services">Services</h4>
<p>A service is an instance of an object that implements a specific set of functionality. Services are stored in service containers and can be retrieved from service providers such as a component's Site and <em>IServiceProvider</em> implementations in general.</p>
<p>The power of services lies in their loose coupling: an application publishes the interface or base class that defines the service, but does not publish the class that implements the service. This design pattern allows the components to request the service and retrieve an instance they can use, but never have to know about the actual implementation nor where it comes from. In additional it</p>
<p>Service containers contain a table of services in the form of type-object key-value pair. To reduce the memory footprint service containers have been designed to support lazy instantiation of service objects.</p>
<h4 id="design-time-attributes">Design-Time Attributes</h4>
<p>Design-Time attributes associate a type or type member with a class that extends its design-time behaviour without creating a functional dependency for the type on the class. This framework makes use of the following attributes:</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;"><center>
<p><strong>Attribute</strong></p>
</center></td>
<td style="text-align: left;"><center>
<p><strong>Description</strong></p>
</center></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><em>DesignerAttribute</em></p></td>
<td style="text-align: left;"><p>Associates a type with a designer.</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><em>TypeConverterAttribute</em></p></td>
<td style="text-align: left;"><p>Associates a type or type member with a type converter.</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><em>EditorAttribute</em></p></td>
<td style="text-align: left;"><p>Associates a type or type member with a type editor.</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><em>DesignerSerializerAttribute</em></p></td>
<td style="text-align: left;"><p>Associates a type with a serializer</p></td>
</tr>
</tbody>
</table>
<h3 id="design-surface-1">Design Surface</h3>
<p>The <em>Design Surface</em> is a thin front-end to the .Net Design-Time framework and is designed to be instantiated and used by the designer tool directly.</p>
<p>The designer surface has to be initialized by the designer tool with a root component type, such as a System Windows Form or an ASP.NET Web Page and is responsible for:</p>
<ul>
<li>Allowing the designer tool to request the surface to be loaded and provide access to the errors if any during the loading process.</li>
<li>Provide the designer tool with a visual representation of the design surface. This is the View that will be presented to the user.</li>
<li>Provide a service container for the underlying components of the framework.</li>
<li>Allow the designer tool to request the persistence of the design surface.</li>
</ul>
<h4 id="state-persistence">State Persistence</h4>
<p>The design surface delegates its loading and persisting to a <em>Designer Loader</em>, which is to be supplied by the designer tool during initialization. The Designer loader implementation of the tool is responsible for feeding the Design-Time Serialization system with an object graph recovered from the persistent storage as well as for persisting to the desired by the tool format an object graph resulted from the serialization of the surface. That way system maintains its format neutrality.</p>
<p>At load-time the Design-Time Serialization system will process the object graph to create component instances, which it will then add to the Design-Time container.</p>
<h4 id="design-time-container">Design-Time Container</h4>
<p>The Design-Time container is designed to be the central storage of components in design mode. They are added by type, instantiated dynamically using reflection together with their associated designer. Each component has an unique identifier - its name, which it gets assigned after being added to the container.</p>
<h4 id="designers-1">Designers</h4>
<p>Designers are classes that are associated with a component type via the ''DesignerAttribute and ''implement the <em>IDesigner</em> interface. Designers are initialized with an instance of a component, which they manage.</p>
<p>The root component, such as a Windows Forms form or an ASP.NET web page, has to implement the <em>IRootDesigner</em> interface, which is special in that it has to provide the visual representation of the component - the View. It is very important to note that the <em>GetView</em> method (Illustration 4: IDesigner and IRootDesigner ,Page 5) is explicitly designed not to return a specific type (such as a Windows Forms <em>Control</em> or an ASP.NET web page), but a generic <em>Object</em>, which can be casted to the appropriate type by the designer tool. The framework implements two Windows Forms root designers - for forms and for custom controls (<em>UserControl</em>).</p>
<figure>
<img src="http://localhost:4000/files/dt_4.png" title="Illustration 4: IDesigner and IRootDesigner" alt="Illustration 4: IDesigner and IRootDesigner" /><figcaption><em>Illustration 4: IDesigner and IRootDesigner</em></figcaption>
</figure>
<p>The designers are responsible for:</p>
<ul>
<li>Performing custom initialization for a component in design mode.</li>
<li>Alter and extend the behaviour or appearance of components in design mode.</li>
<li>Adjust the attributes, events, and properties exposed by a component with which the designer is associated through the powerful type description functionality of .NET.</li>
<li>Add menu items to the shortcut menu of a component.</li>
</ul>
<h4 id="design-time-services">Design-Time Services</h4>
<p>The design surface provides a service container to the rest of the components of the design-time framework and populates it with a default implementation of several important design-time services, including the following.</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;"><center>
<p><strong>Service</strong></p>
</center></td>
<td style="text-align: left;"><center>
<p><strong>Description</strong></p>
</center></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><em>INameCreationService</em></p></td>
<td style="text-align: left;"><p>Generates or validates names for a components.</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><em>ISelectionService</em></p></td>
<td style="text-align: left;"><p>Defines an interface for programmatic component selection and selection tracking, but not a visual one.</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><em>IMenuCommandService</em></p></td>
<td style="text-align: left;"><p>Allows designers to add actions to the right click menu of a component during design time.</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><em>IServiceContainer</em></p></td>
<td style="text-align: left;"><p>The design-time service container, where other parts of the framework can add their provided services.</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><em>IComponentChangeService</em></p></td>
<td style="text-align: left;"><p>Notifies for when components are added/removed from the design surface and also when they get modified.</p></td>
</tr>
</tbody>
</table>
<h3 id="design-time-serialization">Design-Time Serialization</h3>
<p>Design-Time serialization is the process of converting an object graph into a source file (code, markup or other format) that can later be used to recover the object graph. It is based on reflection and type transformation.</p>
<figure>
<img src="http://localhost:4000/files/dt_5.png" title="Illustration 5: Object Graph Serialization" alt="Illustration 5: Object Graph Serialization" /><figcaption><em>Illustration 5: Object Graph Serialization</em></figcaption>
</figure>
<p>The Design-Time serialization differs from the standard object serialization in the following ways:</p>
<ul>
<li>It separates the object that is performing the serialization from the one that is being serialized. Again, the keyword here is loose coupling.</li>
<li>It serializes only properties that have been modified in order to minimize the output as well as provide only meaningful such.</li>
<li>It ignores objects that aren't convertible to instance descriptors instead of throwing exceptions and interrupting the serialization process.</li>
</ul>
<p>The design aims at providing a serialization system that is:</p>
<ul>
<li>Modular - Types are loosely associated with serializers via the <em>DesignerSerializationAttribute</em>.</li>
<li>Format neutral - Each serializer handles the serialization for a specific type and it's up to the serializer to decide in what format the data is to be stored.</li>
<li>Extensible - The system is designed to give priority to objects defined as serializer providers before checking for <em>DesignerSerializationAttribute</em>. Those object feed the serialization system with serializers based on an internally stored type-serializer table. This allows default serialization associations via attributes to be overriden or association of serializers with types that lack a <em>DesignerSerializationAttribute</em>.</li>
<li>Context Sensitive - The serialization process is managed by a serialization manager an instance of which is passed to all serializers to allow them to communicate.</li>
</ul>
<h3 id="the-designer-tool">The Designer Tool</h3>
<p>Based on the proposed design the designer tool can be said to be just a thin front end to the whole Design-Time framework (Illustration 6: A designer tool hosting a design surface, Page 8), with only a few responsibilities:</p>
<ol>
<li>Instantiate the design surface with an arbitrary root component type and host the design surface view.</li>
<li>Provide a two way bridge between the Design-Time serialization system object graph and the data persistence format of choice.</li>
<li>Provide means for editing the metadata of the components in the surface.</li>
<li>Provide a way to add components to to the surface.</li>
</ol>
<figure>
<img src="http://localhost:4000/files/dt_6.png" title="Illustration 6: A designer tool hosting a design surface" alt="Illustration 6: A designer tool hosting a design surface" /><figcaption><em>Illustration 6: A designer tool hosting a design surface</em></figcaption>
</figure>
<h4 id="metadata-editing">Metadata Editing</h4>
<p>With the proposed design the designer tool has access to the ''ISeletionService, ''offered by the design surface, which provides information about the currently selected component as well as a mechanism for notification when the selection changes.</p>
<p>The designer tool will make use of that service to monitor the surface and populate a property grid with the currently selected object's properties using reflection. It will use type transformation (Illustration 7: Type Transformation in action, Page 9) and type editing (Illustration 8: Type Editing in action, Page 9) to provide user friendly facilities for metadata customization.</p>
<figure>
<img src="http://localhost:4000/files/dt_7.png" title="Illustration 7: Type Transformation in action" alt="Illustration 7: Type Transformation in action" /><figcaption><em>Illustration 7: Type Transformation in action</em></figcaption>
</figure>
<figure>
<img src="http://localhost:4000/files/dt_8.png" title="Illustration 8: Type Editing in action" alt="Illustration 8: Type Editing in action" /><figcaption><em>Illustration 8: Type Editing in action</em></figcaption>
</figure>
<h4 id="component-toolbox">Component Toolbox</h4>
<p>Based on the powerful reflection functionality of .NET the designer tool can populate a component toolbox for a particular GUI toolkit by filtering all types that derive from the toolkit's foundation control type (e.g. <em>Control</em> for Windows Forms). The user will be able to drag and drop a component toolbox item onto the design surface which will be handled by the designer for the control under cursor to request the instantiation of the component.</p>
<figure>
<img src="http://localhost:4000/files/dt_9.png" title="Illustration 9: A toolbox" alt="Illustration 9: A toolbox" /><figcaption><em>Illustration 9: A toolbox</em></figcaption>
</figure>
<h2 id="documentation-resources">Documentation Resources</h2>
<ul>
<li><a href="http://www.i-nz.net/files/docs/Building%20User%20Interface%20Design%20Tools%20-%20Ivan%20N.%20Zlatev.pdf">Building User Interface Design Tools</a></li>
<li><a href="http://www.i-nz.net/files/docs/designerhosting/create-and-host-custom-designers-dot-net.html">Create And Host Custom Designers With The .NET Framework 2.0</a></li>
<li><a href="http://msdn2.microsoft.com/en-us/library/37899azc.aspx">Extending Design-Time Support</a></li>
</ul>
<p><a href="http://localhost:4000/Category:Developer Resource" title="wikilink">Category:Developer Resource</a> <a href="http://localhost:4000/Category:WinForms" title="wikilink">Category:WinForms</a></p>
</body>
</html>
