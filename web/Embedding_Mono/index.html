<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <!--[if lt IE 9]>
    <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->
</head>
<body>
<p>by Miguel de Icaza (miguel@ximian.com), Paolo Molaro (lupus@ximian.com)</p>
<p>This document describes how to embed the Mono runtime in your application, and how to invoke managed methods from C, and how to invoke C code from managed code.</p>
<p>For a general overview of why you would like to embed Mono in your application see the <a href="http://localhost:4000/Scripting With Mono" title="wikilink">Scripting With Mono</a> article.</p>
<h1 id="source-code">Source Code</h1>
<p>Source code and samples for Mono embedding can be found in the Mono distribution in the mono/samples/embed directory.</p>
<h1 id="how-embedding-works">How Embedding Works</h1>
<p>Typically you would begin with an existing C application:</p>
<figure>
<img src="http://localhost:4000/files/existing.png" title="http://localhost:4000/files/existing.png" alt="http://localhost:4000/files/existing.png" /><figcaption>http://localhost:4000/files/existing.png</figcaption>
</figure>
<p>Embedding links the mono runtime with your application, so your application now has a full virtual execution system running side-by-side with it. This is done by linking `libmono' with your application (we will cover the details about this later). Once linked, the address space of your application would look like this:</p>
<figure>
<img src="http://localhost:4000/files/linked.png" title="http://localhost:4000/files/linked.png" alt="http://localhost:4000/files/linked.png" /><figcaption>http://localhost:4000/files/linked.png</figcaption>
</figure>
<p>The Mono embedded API exposes the Mono Runtime to the existing C code. The interface exposed by the Mono runtime lets the developer control various aspects of the runtime and inspect the code that runs on the CIL world inside the Mono runtime.</p>
<p>Once you have the Mono runtime initialized, the most interesting thing to do is to load some CIL/.NET code into it. The code can be written in any of the <a href="http://localhost:4000/Languages" title="wikilink">Mono supported languages</a> like C#, Java, IronPython or Visual Basic. This will result in an address space like this:</p>
<figure>
<img src="http://localhost:4000/files/loaded.png" title="http://localhost:4000/files/loaded.png" alt="http://localhost:4000/files/loaded.png" /><figcaption>http://localhost:4000/files/loaded.png</figcaption>
</figure>
<p>The C code is typically referred as <i>unmanaged</i> code, while the CIL code generated by a <a href="http://localhost:4000/Languages" title="wikilink">CIL-compiler</a> is referred to as <i>managed code</i>.</p>
<p>But to make the system more interesting than just load some managed code and have it run side-by-side with your code, it is desirable to have the managed code invoke C code, and the C code invoke managed code.</p>
<p>Managed code can invoke unmanaged code in two ways, using <a href="http://localhost:4000/DllImport" title="wikilink">P/Invoke</a> or using the low-level Mono embedding API.</p>
<p>The result looks like this:</p>
<p>[Image:exposing.png] Now your existing C code can trigger methods in the managed world, and the managed world can react and notify of any interesting changes to the C code:</p>
<figure>
<img src="http://localhost:4000/files/callback.png" title="http://localhost:4000/files/callback.png" alt="http://localhost:4000/files/callback.png" /><figcaption>http://localhost:4000/files/callback.png</figcaption>
</figure>
<p>The loaded assembly can be as simple as you want, some common things that developers have done:</p>
<ul>
<li>Load a library of methods that are wired to the user interface of an application: GUI elements, dialog boxes are then handled on the managed world, while core processing remains in C.</li>
<li>Load user defined code as assemblies, and trigger invocations of those from the existing C code base.</li>
<li>Move some of the development to the managed world, gaining all of the benefits of managed development (exception handling, runtime type checking, just-in-time compilation, rich introspection system, type-safe libraries and more) while keeping your existing investment in C intact.</li>
<li>A launcher that launches background threads to perform some work on behalf of the application.</li>
<li>Embed a web application or a web service server inside your application.</li>
<li>Use Mono to host the user scripting interface, turning Mono and the scripts into a generic plugin interface.</li>
<li>Integrate the Mono object system with third-party object systems.</li>
</ul>
<p>Since the Mono framework is a fairly powerful framework there are almost no limitations on the different kind of applications that you can create with the above setup.</p>
<h1 id="embedding-the-runtime">Embedding the Runtime</h1>
<p>Embedding the runtime consists of various steps:</p>
<ul>
<li>Compiling and linking the Mono runtime</li>
<li>Initializing the Mono runtime</li>
<li>Optionally expose C code to the C#/CIL universe.</li>
</ul>
<p>These are discussed in detail next.</p>
<h3 id="compiling-and-linking">Compiling and Linking</h3>
<p>To embed the runtime, you have to link your code against the Mono runtime libraries. To do this, you want to pass the flags returned by pkg-config to your compiler:</p>
<p><bash> $ pkg-config --cflags --libs mono-2 </bash></p>
<p>is used to get the flags for the JIT runtime.</p>
<p>Like this:</p>
<p><bash> $ gcc sample.c `pkg-config --cflags --libs mono-2` </bash></p>
<p>You can separate the compilation flags from the linking flags, for instance, you can use the following macros in your makefile:</p>
<p><bash> CFLAGS=`pkg-config --cflags mono-2` LDFLAGS=`pkg-config --libs mono-2` </bash></p>
<p>For mono versions before 2.8, use &quot;<strong>mono</strong>&quot; instead of &quot;<strong>mono-2</strong>&quot; in the above commands: the ABI version of the libmono library has changed.</p>
<p>On windows you need to generate an import library for mono.dll by getting the following file:</p>
<p><code> </code><a href="http://github.com/mono/mono/blob/master/msvc/mono.def"><code>http://github.com/mono/mono/blob/master/msvc/mono.def</code></a></p>
<p>and creating mono.lib with the command:</p>
<p><bash> lib /nologo /def:mono.def /out:mono.lib /machine:x86 </bash></p>
<p>Then you link your application with mono.lib.</p>
<h3 id="initializing-the-mono-runtime">Initializing the Mono runtime</h3>
<p>To initialize the JIT runtime, call mono_jit_init, like this:</p>
<div class="c">
<pre><code>&lt;code&gt;
        #include &lt;glib/glib.h&gt;
        #include &lt;mono/jit/jit.h&gt;
        #include &lt;mono/metadata/assembly.h&gt;

        MonoDomain *domain;

        domain = mono_jit_init (domain_name);
&lt;/code&gt;</code></pre>
</div>
<p>That will return a MonoDomain where your code will be executed. domain_name is the name of the main application domain. This call will initialize the default framework version, which could be 2.0 or 4.0, depending on the Mono version used. To specify a framework version, you can use something like:</p>
<div class="c">
<pre><code>&lt;code&gt;
       domain = mono_jit_init_version (&quot;myapp&quot;, &quot;&quot;v2.0.50727);
&lt;/code&gt;</code></pre>
</div>
<p>The first thing you usually do is to load your assembly and execute it:</p>
<div class="c">
<pre><code>&lt;code&gt;
    MonoAssembly *assembly;

    assembly = mono_domain_assembly_open (domain, &quot;file.exe&quot;);
    if (!assembly)
        error ();
&lt;/code&gt;</code></pre>
</div>
<p>In the above example, the contents of `file.exe' will be loaded into the domain. This only loads the code, but it will not execute anything yet. You can replace `file.exe' with another transport file, like `file.dll'.</p>
<p>To start executing code, you must invoke a method in the assembly, or if you have provided a static Main method (an entry point), you can use the convenience function:</p>
<div class="c">
<pre><code>&lt;code&gt;
    retval = mono_jit_exec (domain, assembly, argc - 1, argv + 1);
&lt;/code&gt;</code></pre>
</div>
<p>Make sure you always provide a Main() method and execute it with mono_jit_exec() at startup: this sets up some additional information in the application domain, like the main assembly and the base loading path. You will be able to execute other methods even after Main() returns.</p>
<p>If you want to invoke a different method, look at the <a href="#http://localhost:4000/Invoking_Methods_in_the_CIL_universe" title="wikilink">`Invoking Methods in the CIL universe'</a> section.</p>
<p>Certain features of the runtime like Dll remapping depend on a configuration file, to load the configuration file, just add:</p>
<div class="c">
<pre><code>&lt;code&gt;
         mono_config_parse (NULL);
&lt;/code&gt;</code></pre>
</div>
<p>Which will load the Mono configuration file (typically /etc/mono/config), but if you want to load your own configuration file, pass the filename as the argument to mono_config_parse:</p>
<div class="c">
<pre><code>&lt;code&gt;
         mono_config_parse (&quot;my_mappings&quot;);
&lt;/code&gt;</code></pre>
</div>
<h4 id="configuring-the-runtime">Configuring the Runtime</h4>
<p>When Mono is embedded into an application it needs a way of finding its runtime assemblies and configuration files. By default it will use the system defined locations that the runtime was built with (typically assemblies in /usr/lib/mono and configuration in /etc/mono). This will work out of the box for you.</p>
<p>But if you are using a Mono that was relocated from an original distribution, for example if you are distributing your application with Mono, you must inform the Mono runtime where to find its assemblies and configuration files. To do so, you must call the mono_set_dirs routine:</p>
<div class="c">
<pre><code>&lt;code&gt;
     mono_set_dirs (myapp_lib, myapp_etc);
&lt;/code&gt;</code></pre>
</div>
<p>In Windows this is common since you will install your Mono on a different directory, so for example:</p>
<div class="c">
<pre><code>&lt;code&gt;
mono_set_dirs(&quot;C:\\Mono-2.6.7\\lib&quot;,&quot;C:\\Mono-2.6.7\\etc&quot;);
&lt;/code&gt;</code></pre>
</div>
<h3 id="shutting-down-the-runtime">Shutting down the runtime</h3>
<p>To shutdown the Mono runtime, you have to clean up all the domains that were created, use this function:</p>
<pre><code>    mono_jit_cleanup (domain);</code></pre>
<p>Note that for current versions of Mono, the mono runtime can't be reloaded into the same process, so call mono_jit_cleanup() only if you're never going to initialize it again.</p>
<h3 id="exposing-c-code-to-the-cil-universe">Exposing C code to the CIL universe</h3>
<p>The Mono runtime provides two mechanisms to expose C code to the CIL universe: internal calls and native C code. Internal calls are tightly integrated with the runtime, and provide no support for marshalling between runtime types and C types.</p>
<p>For example, passing a C# string will result into a MonoString* in the C function when using an internal call (that is, it will be a pointer to the managed heap object representing the string). A C# string passed to a P/Invoke C function will result instead in, for example, a utf8 char pointer, depending on the marshalling attributes.</p>
<p>The other option is to use the <a href="http://localhost:4000/DllImport" title="wikilink">Platform Invoke</a> (P/Invoke) to call C code from the CIL universe, using the standard P/Invoke mechanisms.</p>
<p>To use the P/Invoke system, you have to make your C function public, for example:</p>
<div class="c">
<pre><code>&lt;code&gt;
void DoSomething ()
{
   /* ... */
}
&lt;/code&gt;</code></pre>
</div>
<p>To make the runtime lookup the symbol in the current executable, use the special library name <strong>__Internal</strong> like this, in your DllImport attribute:</p>
<div class="csharp">
<pre><code>&lt;code&gt;
using System.Runtime.InteropServices;

[DllImport (&quot;__Internal&quot;, EntryPoint=&quot;DoSomething&quot;)]
static extern void DoSomething ();
&lt;/code&gt;</code></pre>
</div>
<p>The &quot;__Internal&quot; library name will instruct Mono not to look this up in an external library, but to try to satisfy the symbol referenced (DoSomething) in the current executable image.</p>
<p>The P/Invoke framework provides extensive marshalling capabilities (converting strings, converting data types, mapping delegates to function pointers and much more). This is the simplest mechanism to use.</p>
<p>If you want direct access to managed objects you can register C code with the runtime, and later bind to it from managed code.</p>
<p>To register an internal call, use this call in the C code:</p>
<pre><code>    mono_add_internal_call (&quot;Hello::Sample&quot;, sample);</code></pre>
<p>Now, you need to declare this on the C# side:</p>
<pre><code>   using System;
    using System.Runtime.CompilerServices;
    
    class Hello {
    [MethodImplAttribute(MethodImplOptions.InternalCall)]
    extern static string Sample ();
    }</code></pre>
<p>Since this routine returns a string, here is the C definition:</p>
<pre><code>   static MonoString*
    Sample () 
    {
        return mono_string_new (mono_domain_get (), &quot;Hello!&quot;);
    }</code></pre>
<p>Notice that we have to return a `MonoString', and we use the `mono_string_new' API call to obtain this from a string.</p>
<h3 id="windows-considerations">Windows Considerations</h3>
<p>On Windows, it is necessary for you to flag any methods that you want to expose through P/Invoke to be flagged with __dllexport or __declspec(dllexport).</p>
<h1 id="updates-for-mono-version-2.8">Updates for Mono version 2.8+</h1>
<p>To support advanced GC implementations, implement a few optimizations and to do a much needed cleanup, the API and ABI exposed by the Mono library starting with version 2.8 has changed. Most of the API remains unchanged, but a few tweaks may be needed in the build setup and in the code. As much as possible the changes needed will allow the code to compile with both API versions.</p>
<p>The first thing to change is to use mono-2 instead of mono in the pkg-config invocations. To get the preprocessor flags to use during compilation, for example, you'll use:</p>
<p><code>pkg-config --cflags mono-2</code></p>
<p>Please also note that mono may not use GLib anymore internally, so if you use it in your program, make sure you also link to it explicitly. No other change to the build setup should be needed.</p>
<p>Now let's list the changes that may be needed to the source code.</p>
<ul>
<li>The glib.h header file is no longer included in the mono header files, so if you use GLib and relied on mono including the header for you, you'll need to explicitly include the glib.h header now.</li>
</ul>
<ul>
<li>A few functions in the API return a pointer to allocated memory: this memory must be freed with mono_free() instead of g_free().</li>
</ul>
<p>FIXME: provide a list or a small script to allow people to easily grep for them in their code.</p>
<ul>
<li>A few internal headers are not installed anymore. You should simply remove the inclusion on those headers. This includes headers in the mono/utils directory (except mono-logger.h and the newly added mono-publib.h), headers in the mono/io-layer directory and mono/metadata/mempool.h.</li>
</ul>
<ul>
<li>The MonoType struct is no longer fully visible: if you have code that accesses its fields directly, you need to change it to use the accessors that are already provided also in the 1.0 version of the mono API.</li>
</ul>
<p>For example, if you accessed the byref flag of the type using:</p>
<p><code>type-&gt;byref</code></p>
<p>you need to change the code to read:</p>
<p><code>mono_type_is_byref (type)</code></p>
<ul>
<li>The MonoMethodSignature struct is no longer fully visible: if you have code that accesses its fields directly, you need to change it to use the accessors that are already provided also in the 1.0 version of the mono API.</li>
</ul>
<p>For example, if you accessed the return type of the signature using:</p>
<p><code>signature-&gt;ret</code></p>
<p>you need to change the code to read:</p>
<p><code>mono_signature_get_return_type (signature)</code></p>
<ul>
<li>The MonoArray and MonoString structures are no longer visible.</li>
</ul>
<p>If you accessed the fields directly, you need to change the code to use the macros and functions already part of the API.</p>
<ul>
<li>The MonoAssemblyName struct is no longer fully visible: to access its fields</li>
</ul>
<p>you need to use the newly-provided accessors. Note also that it can't be allocated on the stack anymore and you'll need to create and destroy it with the following API:</p>
<p><code>MonoAssemblyName *aname = mono_assembly_name_new (&quot;mscorlib&quot;);</code><br /><code>mono_assembly_name_free (aname);</code></p>
<ul>
<li>The MonoMethodHeader object is now transient: you need to free it when you're done to avoid leaking by calling the (already existing and safe to call) function mono_metadata_free_mh ().</li>
</ul>
<ul>
<li>Array API changes: the integer types that represent arry lengths and array boundaries has changed to uintptr_t and intptr_t. This allows us to transparently provide a mono build that supports 64 bit indices on 64 bit systems. The affected APIs are:</li>
</ul>
<p><code> mono_array_new ()</code><br /><code> mono_array_new_full ()</code><br /><code> mono_array_new_specific ()</code><br /><code> mono_array_length ()</code></p>
<ul>
<li>Profiler API changes.</li>
</ul>
<p>Mono can now support multiple profilers running at the same time. The profiler initialization sequence must first install the profiler and only after that install the callbacks and set the event mask.</p>
<p>Also note that objects can move in memory. Use the</p>
<p><code> void mono_profiler_install_gc_moves    (MonoProfileGCMoveFunc callback);</code></p>
<p>function to get notifications of the old and new addresses of objects as they are moved.</p>
<ul>
<li>The mono logger API now exposes only the ability to set the trace level and trace mask with the two functions:</li>
</ul>
<p><code>void mono_trace_set_mask_string (const char *value);</code><br /><code>void mono_trace_set_level_string (const char *value);</code></p>
<ul>
<li>The following methods and structures (which were really unlikely to be used/useful to anyone outside of the mono internals) are not part of the public API anymore:</li>
</ul>
<p><code>mono_remote_class() MonoRemoteClass</code><br /><code>ves_icall_System_Environment_GetOSVersionString()</code><br /><code>mono_alloc_special_static_data()/mono_get_special_static_data()</code></p>
<h1 id="invoking-methods-in-the-cil-universe">Invoking Methods in the CIL universe</h1>
<p>Calling a method in the CIL universe from C requires a number of steps:</p>
<ul>
<li>Obtaining the MonoMethod handle to the method.</li>
<li>The method invocation.</li>
</ul>
<p>To get a MonoMethod there are several ways.</p>
<p>You can get a MonoClass (the structure representing a type) using:</p>
<pre><code>        MonoImage *
        mono_assembly_get_image  (MonoAssembly *assembly);

    MonoClass *
    mono_class_from_name (MonoImage *image, const char* name_space, const char *name);</code></pre>
<p>and then loop in the returned class method array until you get the one you're looking for. There are examples of such searches as static functions in several C files in metadata/*.c: we need to expose one through the API and remove the duplicates.</p>
<p>The other, simpler, way is to use the functions in debug-helpers.h: there are examples of their use in monograph, mint and the jit as well. You basically use a string description of the method, like:</p>
<pre><code>        &quot;System.Object:GetHashCode()&quot;</code></pre>
<p>and create a MonoMethodDesc out of it with:</p>
<pre><code>#include &lt;mono/metadata/debug-helpers.h&gt;

MonoMethodDesc* mono_method_desc_new (const char *name, gboolean include_namespace);</code></pre>
<p>You can then use:</p>
<pre><code>MonoMethod*     mono_method_desc_search_in_class (MonoMethodDesc *desc, MonoClass *klass);
MonoMethod*     mono_method_desc_search_in_image (MonoMethodDesc *desc, MonoImage *image);</code></pre>
<p>and</p>
<pre><code>#include &lt;mono/metadata/assembly.h&gt;

MonoImage    *mono_assembly_get_image  (MonoAssembly *assembly);</code></pre>
<p>to search for the method in a class or in an image. You would typically do this just once at the start of the program and store the result for reuse somewhere.</p>
<h2 id="invoking-a-method">Invoking a Method</h2>
<p>You can invoke methods either with [#Unmanaged_to_Managed_Thunks|Unmanaged to Managed Thunks] which create a custom version of an invocation method or by using the mono_runtime_invoke () methods.</p>
<p>The unmanaged to managed thunks are faster because they will create a custom trampoline from unmanaged code to managed code for the particular method signature that you are invoking. The mono_runtime_invoke methods can be used with any arguments and any method signatures.</p>
<p>If you are doing a few invocations, mono_runtime_invoke will probably suffice, but if you are adding this to a code that in your code that requires the best possible performance, you will want to use the thunks.</p>
<p>There are two functions to call a managed method:</p>
<div class="c">
<pre><code>&lt;code&gt;
    MonoObject*
    mono_runtime_invoke         (MonoMethod *method, void *obj, void **params,
                                 MonoObject **exc);
    and
    MonoObject*
    mono_runtime_invoke_array   (MonoMethod *method, void *obj, MonoArray *params,
                                 MonoObject **exc);
&lt;/code&gt;</code></pre>
</div>
<p>obj is the 'this' pointer, it should be NULL for static methods, a MonoObject* for object instances and a pointer to the value type for value types.</p>
<p>The params array contains the arguments to the method with the same convention: MonoObject* pointers for object instances and pointers to the value type otherwise. The _invoke_array variant takes a C# object[] as the params argument (MonoArray *params): in this case the value types are boxed inside the respective reference representation.</p>
<p>From unmanaged code you'll usually use the mono_runtime_invoke() variant.</p>
<p>Note that this function doesn't handle virtual methods for you, it will exec the exact method you pass: we still need to expose a function to lookup the derived class implementation of a virtual method (there are examples of this in the code, though).</p>
<p>You can pass NULL as the exc argument if you don't want to catch exceptions, otherwise, *exc will be set to the exception thrown, if any. if an exception is thrown, you can't use the MonoObject* result from the function.</p>
<p>If the method returns a value type, it is boxed in an object.</p>
<p>For example, to invoke the following C# methods:</p>
<div class="c">
<pre><code>&lt;code&gt;
  class MyClass {
    static void Foo (int value) {
      ...
    }

    int Bar (string name) {
      ...
    }
  }
&lt;/code&gt;</code></pre>
</div>
<p>assuming you got the corresponding MonoMethod* in foo_method and bar_method and this_arg is a MonoObject* of type MyClass, you simply execute:</p>
<div class="c">
<pre><code>&lt;code&gt;
  /* we execute methods that take one argument */
  void *args [1];
  int val = 10;
  /* Note we put the address of the value type in the args array */
  args [0] = &amp;val;

  /* execute Foo (10);
   * it&#39;s a static method, so use NULL as the second argument.
   */
  mono_runtime_invoke (foo_method, NULL, args, NULL);

  /* a string is a reference, so we put it directly in the args array */
  args [0] = mono_string_new (domain, &quot;Hello&quot;);
  /* execute my_class_instance.Bar (&quot;Hello&quot;);
   * See the Creating Objects section to learn how to get this_arg.
   */
  MonoObject *result = mono_runtime_invoke (bar_method, this_arg, args, NULL);
  /* we always get a MonoObject* from mono_runtime_invoke (), so to get
   * the integer value we need to unbox (which returns a pointer to
   * the value stored in the object) and dereference.
   */
  int int_result = *(int*)mono_object_unbox (result);
&lt;/code&gt;</code></pre>
</div>
<h3 id="creating-objects">Creating objects</h3>
<p>Creating an object involves two separate actions: allocating the memory and invoking the constructor.</p>
<p>For constructors that take no arguments this is very simple:</p>
<div class="c">
<pre><code>&lt;code&gt;
  /* we usually get the class we need during initialization */
  MonoImage *image = mono_assembly_get_image (assembly);
  MonoClass *my_class = mono_class_from_name (image, &quot;MyNamespace&quot;, &quot;MyClass&quot;);
  ...
  /* allocate memory for the object */
  MonoObject *my_class_instance = mono_object_new (domain, my_class);
  /* execute the default argument-less constructor */
  mono_runtime_object_init (my_class_instance);
&lt;/code&gt;</code></pre>
</div>
<p>For more complex constructors or if you want to have more control of the execution of the constructor, you can use mono_runtime_invoke() as explained in the previous section, after getting the MonoMethod* representing the constructor:</p>
<div class="c">
<pre><code>&lt;code&gt;
  /* execute my_class_instance = new MyClass (&quot;Mono rocks&quot;); */
  MonoObject *my_class_instance = mono_object_new (domain, my_class);
  void *args [1];
  args [0] = mono_string_new (domain, &quot;Mono rocks&quot;);
  /* constructor methods return void, so we ignore the return value,
   * the constructed object is my_class_instance.
   */
  mono_runtime_invoke (ctor_method, my_class_instance, args, NULL);
&lt;/code&gt;</code></pre>
</div>
<h3 id="data-types">Data types</h3>
<p>Unlike <a href="http://localhost:4000/PInvoke" title="wikilink">PInvoke</a>, there is no intermediate layer that translates the managed types into unmanaged typed or the other way around. With the embedded runtime, when you register an internal call, or when you call a method, you need to use the data types expected by the runtime.</p>
<p>This means that you need to convert your C types into Mono runtime types before you can pass them to Mono, or you must convert those Mono types to C types before you can consume them&quot;</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;"><p>C Type</p></th>
<th style="text-align: left;"><p>Mono Type</p></th>
<th style="text-align: left;"><p>C to Mono</p></th>
<th style="text-align: left;"><p>Mono to C</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><p>strings, char *</p></td>
<td style="text-align: left;"><p>MonoString *</p></td>
<td style="text-align: left;"><p>mono_string_new, mono_string_new_len, mono_string_new_wrapper, mono_string-new_utf16</p></td>
<td style="text-align: left;"><p>mono_string_to_utf8, mono_string_to_utf16</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p>array of x</p></td>
<td style="text-align: left;"><p>MonoArray *</p></td>
<td style="text-align: left;"><p>mono_array_new, mono_array_new_full, mono_array_new_specific</p></td>
</tr>
<tr class="odd">
</tr>
</tbody>
</table>
<p>See the embedded API documentation for more details about these.</p>
<h3 id="unmanaged-to-managed-thunks">Unmanaged to Managed Thunks</h3>
<p>With Mono 2.0 we introduced a new function that can wrap a MonoMethod into a function pointer:</p>
<div class="c">
<pre><code>&lt;code&gt;
    void* mono_method_get_unmanaged_thunk (MonoMethod *method);
&lt;/code&gt;</code></pre>
</div>
<p>You'll be able to store the returned pointer in a function pointer with the proper signature and call that directly from C:</p>
<div class="c">
<pre><code>&lt;code&gt;
    typedef gint32 (*GetHashCode) (MonoObject *obj);

    GetHashCode func = mono_method_get_unmanaged_thunk (System_Object_GetHashCode_method);

    gint32 hashvalue = func (myobject);
&lt;/code&gt;</code></pre>
</div>
<p>Another approach is calling <a href="http://msdn.microsoft.com/en-us/library/system.runtime.interopservices.marshal.getfunctionpointerfordelegate.aspx">Marshal.GetFunctionPointerForDelegate ()</a> either from managed code, or using mono_runtime_invoke ().</p>
<h3 id="c-to-c-delegate-registration">C# to C delegate registration</h3>
<p>Another common pattern to have C code invoke C# code is to pass C# delegates to C through the <a href="http://localhost:4000/Interop with Native Libraries" title="wikilink">Interop with Native Libraries</a> support in Mono.</p>
<p>When you pass a C# delegate to C, the Mono runtime will create the thunk automatically for you. The function received on the C side will be a function pointer that points to a thunk that invokes code in the C# world.</p>
<p>The C# side of the code would look like this:</p>
<div class="csharp">
<pre><code>&lt;code&gt;
using System.Runtime.InteropServices;

class Demo {
    delegate int MyCallback1 (int a, int b);

    [DllImport (&quot;MyRuntime&quot;)]
    extern static void RegisterCallback (MyCallback1 callback1);

    static int Add (int a, int b) { return a + b; }
    static int Sub (int a, int b) { return a - b; }

    void Init ()
    {
        // This one registers the method &quot;Add&quot; to be invoked back by C code
        RegisterCallback (Add);
    }
}
&lt;/code&gt;</code></pre>
</div>
<p>Then your C code would look like this:</p>
<div class="c">
<pre><code>&lt;code&gt;
typedef int (*callback-t) (int a, int b);
static callback_t my_callback;

void RegisterCallback (my_callback_t cb)
{
    my_callback = cb;
}

int InvokeManagedCode (int a, int b)
{
    if (my_callback == NULL){
         printf (&quot;Managed code has not initialized this library yet&quot;);
         abort ();
    }
    return (*my_callback) (a, b);
}
&lt;/code&gt;</code></pre>
</div>
<h2 id="threading-issues">Threading issues</h2>
<p>If your application creates threads on its own, and you want them to be able to interact with Mono, you have to register the thread so that the runtime knows about it.</p>
<p>To do so, call the mono_thread_attach() function before you execute any other Mono API or before manipulating any managed object.</p>
<h2 id="signal-handling">Signal handling</h2>
<p>Mono consumes a set of signals during execution that your applications will not be able to consume, here is what these are:</p>
<ul>
<li>SIGPWR, SIGXCPU: these are used internally by the GC and pthreads.</li>
<li>SIGFPE: caught so we can turn that into an exception</li>
<li>SIGQUIT, SIGKILL to produce ExecutionEngineException.</li>
<li>SIGSEGV: to produce NullReferenceExceptions</li>
</ul>
<p>One signal picked at startup time between SIGRTMIN and SIGRTMAX. The signal is picked up by finding a signal in that range which is set to SIG_DFL.</p>
<p>Optionally:</p>
<ul>
<li>SIGUSR2: this is used when --trace=disable is passed on the command line and its used to turn on/off the output of trace.</li>
</ul>
<p>Currently Mono does not provide a mechanism for signal chaining, but one might be available in the future, see <a href="http://bugzilla.ximian.com/show_bug.cgi?id=75990">Bug #75990</a> for information on the current status of this feature.</p>
<h1 id="api-documentation">API Documentation</h1>
<p>See <a href="http://go-mono.com/docs/index.aspx?tlink=root:/embed">here</a>.</p>
<h1 id="common-problems">Common Problems</h1>
<h2 id="threads">Threads</h2>
<p>If your applications has threads that will access Mono, access Mono variables, point to Mono objects, be called back by Mono, these threads must be registered with the Mono runtime using the <code>mono_thread_attach</code>.</p>
<h2 id="missing-functionality">Missing functionality</h2>
<p>If the embedding API is missing some functionality, you might be able to work around it by invoking managed code using mono_runtime_invoke (), i.e. for creating delegates you can call Delegate.CreateDelegate () etc.</p>
<h2 id="chickenegg">Chicken/Egg</h2>
<p>If you have a .NET app which P/Invokes to an unmanaged library, which embeds Mono for basically 100% of its logic, bad things can happen:</p>
<p>Under Linux, libmono is statically linked by default. If you p/invoke a library that it turn is linked against libmono, you'll end up with 2 runtime instances.</p>
<p>Even if you link libmono dynamically (there is a `configure' switch for this), you must take care to initialize the runtime only once. This means that you can't call mono_jit_init/cleanup from the SO.</p>
<h1 id="samples">Samples</h1>
<p>See the sample programs in <a href="http://anonsvn.mono-project.com/viewvc/trunk/mono/samples/embed/">mono/samples/embed</a> for examples of embedding the Mono runtime in your application.</p>
</body>
</html>
